---
title: "A walk-through of R package 'MFA'"
author: "Yulin Chen, Stephanie Wuerth, Eren Bilir, Jim Oreluk"
date: "Dec. 3 2016"
output: rmarkdown::html_vignette
fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
## Overview

Multifactor Analysis is a statistical method that expands the concept of principal component analysis to a multi-table data set. Principal component analysis (PCA) traditionally takes in one 2D data table of observations and variables and uses singular value decomposition (SVD) along with other analytical methods from linear algebra to perform dimension reduction on the data table, or in other words, compute a smaller number of new compound variables called 'components' which can describe the variation seen among the observations. This technique is useful because it gives the user insight into the underlying structure of the data table, or patterns in the data, that would be difficult to see without reducing dimensions. Multifactor Analysis takes this approach further by first doing SVD on each individual table to compute additional constraints for a second generalized SVD (GSVD) performed on a 'grand' data table made up of all individual tables-- in effect, allowing this 'grand' data table to itself undergo a form of PCA. A more detailed description of multifactor analysis and a step by step guide to the calculations performed in multifactor analysis can be found in reference 1. 

## Package contents

[The MFA constructor: mfa.R](#id1)

[The print method: print-mfa.R](#id2)

[The five plotting methods: plot_compromise.R, plot_ev.R, plot_loading.R, plot_partial_fac.R, plot_inertia_pie.R](#id3)

[Additional descriptive statistics: lg.R, lg_table.R, rv.R, rv_table.R, obs_dim.R, var_dim.R, bootstrap_factorscores.R](#id4)

[Load a toy data set to experiment with: loadWineData.R](#id5)

[Shiny App: runExample.R](#id6)

[References](#id7)

<a id="id1"></a> 

## The MFA constructor

The MFA constructor function is the keystone of the package. It relies principally on two instances of R's built-in SVD function, as will be seen in the walk-through of this function below. 

MFA is intended for use on multi-table data sets, but for computational convenience, the user hands their raw data tables to mfa.R as a single matrix or data.frame along with a secondary input 'sets' which specifies how to divide the data back into individual tables. The user also defines how many factors to compute in the analysis with 'ncomps', and finally gives logical or numeric inputs to 'center' and 'scale' to define whether or not the function should perform centering and scaling for each active variable. The mfa.R constructor has in place careful checks for each of these types of input to safeguard against user error propagating into the analysis. Below is an example of how the check function ensures that the data inputs are in the right format:   

```{r, eval=FALSE}
check_inputs = function(data, sets, ncomps, center, scale) {
  if (!is.matrix(data) &
      !is.data.frame(data) ) {
    stop("'data' must be a matrix or data.frame containing the data set")
  }
...
}
```

After checking the inputs, the constructor function then partitions the raw data matrix into the list of tables specified by 'sets', and then scales and centers each table in that list. The resulting list of centered and scaled tables is called 'xTables' in the code. We then come to the first instance of SVD in the function, as each table is separately decomposed inside a for loop. These SVDs are performed by the code snippet below.  

```{r, eval=FALSE}
for (k in 1:length(xTables)) {
    val = svd(xTables[[k]])
    alpha[[k]] = (val$d[1]^-2)
    aVector = c(aVector, rep(alpha[[k]], ncol(val$u)) )
  }
```

The resulting 'alpha' object is a list of table weights computed from the first singular values of each table's SVD. These weights are propagated into the next SVD calculation via the object 'aVector', which stores these values in a vector which repeates each alpha value sequentially a number of times that matches the sizes of the individual tables. 'aVector' becomes one of two constraints on the next SVD calculation. The second constraint is a vector 'm' which represents a simple measure of 'observation masses' based on how many objects are included in the analysis, shown in the snippet below: 

```{r, eval=FALSE}
  nObs = nrow(xTables[[1]])
  m = rep(1/nObs, nObs)
```

With these two constraints in place, the individual 'xTables' are concatenated into a single matrix 'X', and the second instance of SVD can take place on 'X' within the imposed constraints. The GSVD of 'X' is shown in the code snippet below, along with comments reminding the user of which equation is being implemented in each step: 

```{r, eval=FALSE}
  # X = P \Delta Q^T
  xTilde = diag(m^(1/2)) %*% X %*% diag(aVector^(1/2))  # \tilde{X} = M^{1/2} A W^{1/2}
  xDecomp = svd(xTilde)  # \tilde{A} = P \Delta Q^T
  eigenvalues = (xDecomp$d)^2

  P = diag(m^(-1/2)) %*% xDecomp$u
  Q = diag(aVector^(-1/2)) %*% xDecomp$v
```

The remainder of the MFA constructor calculates common factor scores, partial factor scores, and matrix loadings from P, Q, and the individual table weights ('alpha') from before, and packages the final MFA object for output. The associated methods included in the package allow the user to explore this final output more fully. The following sections describe these methods. 

<a id="id2"></a> 

## The print method

Because there is a lot of information contained in the MFA object that a user might like to have easy access to, developing a good print method is a tricky task. If you flood the user with too much data, using the print method is not any better than just displaying the entire object. But giving too little data is also not useful. Therefore, our team developed a middle ground that combines automatic output with some reactive prompts that allow a user to define the amount of information that they are interested in. 

The print method begins by giving the user a lot of information about the structure of their MFA object, and instructions on how to access each individual component of the MFA object in full, followed by a brief summary of key values and factor scores. Below is a sample of output from the print method, showing the parts that print automatically:   

```{r, eval=FALSE}
Summary of Multiple Factor Analysis (mfa) object: 
 
This object contains information on the data inputs as well as on the analysis outputs. 
You can access the full contents of any of these components using name_mfaObject$component_name.  
For example, if you are interested in viewing the eigenvalues for an mfa object called 'x',  
you would type 'x$eigenvalues'. 
 
Your MFA object contains the following items : 
################################################################################
           Component Name    ::    Description
################################################################################
                     data    ::    raw data input by user 
                     sets    ::    number of active variables across all the tables 
                   ncomps    ::    number of factors computed in the analysis 
                   center    ::    whether centering was performed on the data 
                    scale    ::    whether scaling was performed on the data 
              eigenvalues    ::    eigenvalues 
             factorScores    ::    common factor scores 
                    alpha    ::    table weights 
      partialFactorScores    ::    partial factor scores 
           matrixLoadings    ::    variable loadings 
                        X    ::    the processed concatenated data table 
################################################################################

Number of tables considered in this multiple factor analysis: 10
Number of active variables: 53
Maximum Eigenvalue: 0.7702551
Common factor scores for first two components: 
         Dim1    Dim2
    1 : -0.98 : +0.16 
    2 : -0.81 : +0.03 
    3 : -0.76 : -0.45 
    4 : -1.11 : -0.17 
    5 : +1.37 : -0.13 
    6 : +1.26 : -0.11 
    7 : +0.81 : +0.20 
    8 : +0.93 : +0.41 
    9 : -0.67 : +0.37 
   10 : +0.07 : -0.76 
   11 : -0.48 : +0.51 
   12 : +0.37 : -0.08 
################################################################################
```

However, the partial factor scores and variable loadings represent a large amount of information that is difficult to summarize effectively. Each individual table will have its own matrix of partial factor scores and variable loadings, so even looking at only the first two components would return multiple tables at once. So to navigate these aspects, we constructed a set of prompts to allow the user to determine their preferences specifically. Below is a sample of output in answer to the variable loadings prompt. A similar prompt exists for viewing partial factor scores.

```{r, eval=FALSE}
################################################################################

Variable loadings:
################################################################################
If you would like to see variable loadings for a single table,
  enter the corresponding table number (1 through 10). 
 To see variable
  loadings for all tables, type ALL. 
 To skip seeing any variable loadings, type NONE (case-sensitive), or Return.1
Loadings for the first two components, showing table 1 of 10: 
         Dim1    Dim2
   V1 : -0.29 : +0.32 
   V2 : -0.27 : -0.25 
   V3 : -0.26 : +0.40 
   V4 : +0.24 : -0.18 
   V5 : +0.29 : +0.16 
   V6 : -0.23 : +0.13 
```

We chose to only display only the first two components in each case, even when then 'ncomps' input is greater than two, because this ties in effectively with the plotting methods: the values returned represent the coordinates of the corresponding two-dimensional plot. For example, variable loadings along the first two dimensions for table 1 correspond to the coordinates of the 2D variable loadings plot for table 1. The various plotting methods will be discussed futher in the section below. 

<a id="id3"></a> 

## Five plotting methods 

Five plotting methods were developed for this package. 

Once you have installed this package, you should be able to produce all of the plots shown here by loading our sample wine data set. The code below demonstrates how to load the data set and more information on the the data set, and how to create your mfa object with the constructor function.

```{r, echo=TRUE}
library(MFA)

d <- loadWineData()
# also get some information on the wine data set such as wine names (obsnames) and variable names
varlabels <- loadWineInfo()$varkeys
obslabels <- loadWineInfo()$obskeys
obscolors <- loadWineInfo()$colors

s = list(  seq(2,7), seq(8,13), seq(14,19), seq(20,24),
           seq(25,30), seq(31,35), seq(36,39), seq(40,45),
           seq(46,50), seq(51,54) )
a = mfa(d, s)
```

plot_compromise.R generates a plot of the common factor scores. An example is shown below for a toy data set relating to wines. This plot shows how the different objects in the data set (in this case wines, four from each of regions, New Zealand (NZ), France (FR), and California (CA)) vary over the first two dimensions (analogous to principal components) computed in the MFA. At minimum, you should pass in your mfa object of interest this method. There are several optional arguments to customize your plot. Here we use obsnames to pass in labels for our variables (in this case wine region + index), and textcolor to color our wines by region.

```{r, fig.cap="Compromise or common factor scores of the wine data set", fig.show='hold', fig.width=4, echo=TRUE}
plot_compromise(a, obsnames = obslabels, textcolor = obscolors )
```

plot_loading.R generates a plot of the variable loadings unique to each individual table. Below is an example of the variable loadings plot for table 2 (corresponding to a particular wine assessor) of the wine data set. Again we have the option of passing in labels for our variables. In this example the variables correspond to characteristics in the wines' flavor profile as detected by the assessor. By default the first two components are used as the x and y dimensions, but one can use other dimensions with the arguments dim1 and dim2. 

```{r, fig.cap="Variable loadings for assessor 2", fig.show='hold', fig.width=4, echo=TRUE}
plot_loading(a, varnames = varlabels, table = 2)
```

Similarly plot_partial_fac.R generates a plot of the partial factor scores unique to each individual table, or in our case to each wine assessor. Below is a plot of the partial factor scores plot for assessor 2. We can see that wines from each of the 3 regions seem to cluster together in this reduced-dimension space.   

```{r, fig.cap="Partial factor scores for assessor 2", fig.show='hold', fig.width=4, echo=TRUE}
plot_partial_fac(a, table = 2, obsnames = obslabels, textcolor = obscolors)
```

plot_ev.R generates a bar graph of the eigenvalues computed in the MFA. We can see that the first eigenvalue is much larger than the others, indicating that most of the variation in this dataset is captured by the first component.

```{r, fig.cap="Eigenvalue magnitudes from mfa on the wine data set", fig.show='hold', fig.width=4, echo=TRUE}
plot_ev(a)
```

And finally, plot_inertia_pie.R generates a pie chart showing the variance explained by each of the components, similar to the bar graph of the eigenvalues, but visualized in a different way. Again we see the relative importance of the first component.

```{r, fig.cap="Percent inertia contribution of each component in the wine data mfa", fig.show='hold', fig.width=4, echo=TRUE}
plot_inertia_pie(a, radius=1, cexlab=0.7)
```

<a id="id4"></a> 

## Additional descriptive statistics

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

<a id="id5"></a> 

## Toy data set 

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

<a id="id6"></a> 

## Shiny App

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))

<a id="id7"></a> 

## References 

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.
